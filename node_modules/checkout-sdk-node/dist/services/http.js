"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.put = exports.post = exports.patch = exports.get = exports.default = exports.createAccessToken = exports._delete = void 0;
var _nodeFetch = _interopRequireDefault(require("node-fetch"));
var _axios = _interopRequireDefault(require("axios"));
var _config = require("../config");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; } /* eslint-disable no-throw-literal */
const pjson = require('../../package.json');
function buildResponse(config, response) {
  if (config.csv) {
    return buildCsvResponse(response);
  }
  return buildJsonResponse(response);
}
function buildCsvResponse(_x) {
  return _buildCsvResponse.apply(this, arguments);
}
function _buildCsvResponse() {
  _buildCsvResponse = _asyncToGenerator(function* (response) {
    const txt = yield response.text();
    const csv = Buffer.from(txt);
    return {
      status: response.status,
      csv
    };
  });
  return _buildCsvResponse.apply(this, arguments);
}
function buildJsonResponse(response) {
  return response.text().then(text => {
    const data = !text ? {} : JSON.parse(text);
    const headers = getResponseHeaders(response);
    return {
      status: response.status,
      json: data,
      headers
    };
  });
}
function getRequestHeaders(config, request, authHeader, idempotencyKey) {
  let headers = _objectSpread(_objectSpread({}, config.headers), {}, {
    Authorization: authHeader,
    'Cache-Control': 'no-cache',
    pragma: 'no-cache',
    'user-agent': `checkout-sdk-node/${pjson.version}`
  });
  if (request && request.headers) {
    headers = _objectSpread(_objectSpread({}, headers), request.headers);
  }
  if (!config.formData) {
    headers['Content-Type'] = config.csv ? 'text/csv' : 'application/json';
  }
  if (idempotencyKey !== undefined) {
    headers['Cko-Idempotency-Key'] = idempotencyKey;
  }
  return headers;
}
function getResponseHeaders(response) {
  // Return CKO response headers when available

  if (_config.REQUEST_ID_HEADER in response.headers.raw()) {
    const requestId = response.headers.raw()[_config.REQUEST_ID_HEADER] || response.headers.raw()['request-id'];
    const version = response.headers.raw()[_config.API_VERSION_HEADER] || response.headers.raw().version;
    return {
      'cko-request-id': requestId ? requestId[0] : '',
      'cko-version': version ? version[0] : ''
    };
  }
  return {};
}
function getResponseAxiosHeaders(response) {
  // Return CKO response headers when available

  if (_config.REQUEST_ID_HEADER in response.headers) {
    const requestId = response.headers[_config.REQUEST_ID_HEADER] || response.headers['request-id'];
    const version = response.headers[_config.API_VERSION_HEADER] || response.headers.version;
    return {
      'cko-request-id': requestId ? requestId[0] : '',
      'cko-version': version ? version[0] : ''
    };
  }
  return {};
}
function buildAxiosResponse(config, response) {
  if (config.csv) {
    return {
      status: response.status,
      csv: Buffer.from(response.data)
    };
  }
  return {
    status: response.status,
    json: response.data,
    headers: getResponseAxiosHeaders(response)
  };
}

// For 'no body' response, replace with empty object
const bodyParser = rsp => rsp.text().then(text => text ? JSON.parse(text) : {});
const isTokenExpired = (tokenExpiry, currentTimestamp) => tokenExpiry < currentTimestamp;
const createAccessToken = exports.createAccessToken = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator(function* (config, httpClient, body) {
    const requestBody = body || {
      grant_type: 'client_credentials',
      client_id: config.client,
      client_secret: config.secret,
      scope: config.scope.join(' ')
    };
    let access;
    switch (httpClient) {
      case 'axios':
        access = yield (0, _axios.default)({
          url: config.host.includes('sandbox') ? _config.SANDBOX_ACCESS_URL : _config.LIVE_ACCESS_URL,
          method: 'post',
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            Accept: 'application/json'
          },
          data: new URLSearchParams(requestBody),
          timeout: config.timeout,
          httpsAgent: config.agent
        }).catch(error => {
          if (error.response) {
            throw {
              status: error.response.status,
              json: error.toJSON()
            };
          } else if (error.request) {
            throw {
              request: error.request,
              json: error.toJSON()
            };
          } else {
            throw {
              message: error.message,
              json: error.toJSON()
            };
          }
        }).then(response => ({
          status: response.status,
          json: response.data
        }));
        return access;
      default:
        access = yield (0, _nodeFetch.default)(config.host.includes('sandbox') ? _config.SANDBOX_ACCESS_URL : _config.LIVE_ACCESS_URL, {
          method: 'post',
          timeout: config.timeout,
          agent: config.agent,
          body: new URLSearchParams(requestBody),
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            Accept: 'application/json'
          }
        });
        if (!access.ok) {
          const json = bodyParser(access);
          throw {
            status: access.status,
            json
          };
        }
        return access.text().then(text => {
          const data = text ? JSON.parse(text) : {};
          return {
            status: access.status,
            json: data
          };
        });
    }
  });
  return function createAccessToken(_x2, _x3, _x4) {
    return _ref.apply(this, arguments);
  };
}();

// eslint-disable-next-line consistent-return
const httpRequest = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator(function* (httpClient, method, path, config, auth, request, idempotencyKey) {
    let authHeader = null;
    if (auth) {
      authHeader = auth;
    } else if (config.client) {
      // TODO Refactor OAuth credentials request

      // For NAS
      // If an access tokens exists, and it's not expired re-use it
      if (config.access && !isTokenExpired(config.access.expires, new Date())) {
        authHeader = `${config.access.type} ${config.access.token}`;
      } else {
        const access = yield createAccessToken(config, httpClient);
        authHeader = `${access.json.token_type} ${access.json.access_token}`;

        // eslint-disable-next-line no-param-reassign
        config.access = {
          token: access.json.access_token,
          type: access.json.token_type,
          scope: access.json.scope,
          expires: new Date(new Date().getTime() + access.json.expires_in)
        };
      }
    }
    const headers = getRequestHeaders(config, request, authHeader, idempotencyKey);
    let response;
    switch (httpClient) {
      case 'axios':
        response = yield (0, _axios.default)({
          url: path,
          method,
          headers,
          data: config.formData ? request : JSON.stringify(request),
          timeout: config.timeout,
          httpsAgent: config.agent
        }).catch(error => {
          if (error.response) {
            throw {
              status: error.response.status,
              json: error.toJSON()
            };
          } else if (error.request) {
            throw {
              request: error.request,
              json: error.toJSON()
            };
          } else {
            throw {
              message: error.message,
              json: error.toJSON()
            };
          }
        }).then(res => buildAxiosResponse(config, res));
        return response;
      default:
        response = yield (0, _nodeFetch.default)(path, {
          method,
          timeout: config.timeout,
          agent: config.agent,
          body: config.formData ? request : JSON.stringify(request),
          headers
        });
        if (!response.ok) {
          const json = bodyParser(response);
          throw {
            status: response.status,
            json
          };
        }
        return buildResponse(config, response);
    }
  });
  return function httpRequest(_x5, _x6, _x7, _x8, _x9, _x10, _x11) {
    return _ref2.apply(this, arguments);
  };
}();
const get = exports.get = /*#__PURE__*/function () {
  var _ref3 = _asyncToGenerator(function* (httpClient, path, config, auth) {
    return httpRequest(httpClient, 'get', path, config, auth);
  });
  return function get(_x12, _x13, _x14, _x15) {
    return _ref3.apply(this, arguments);
  };
}();
const post = exports.post = /*#__PURE__*/function () {
  var _ref4 = _asyncToGenerator(function* (httpClient, path, config, auth, request, idempotencyKey) {
    return httpRequest(httpClient, 'post', path, config, auth, request, idempotencyKey);
  });
  return function post(_x16, _x17, _x18, _x19, _x20, _x21) {
    return _ref4.apply(this, arguments);
  };
}();
const patch = exports.patch = /*#__PURE__*/function () {
  var _ref5 = _asyncToGenerator(function* (httpClient, path, config, auth, request) {
    return httpRequest(httpClient, 'patch', path, config, auth, request);
  });
  return function patch(_x22, _x23, _x24, _x25, _x26) {
    return _ref5.apply(this, arguments);
  };
}();
const put = exports.put = /*#__PURE__*/function () {
  var _ref6 = _asyncToGenerator(function* (httpClient, path, config, auth, request) {
    return httpRequest(httpClient, 'put', path, config, auth, request);
  });
  return function put(_x27, _x28, _x29, _x30, _x31) {
    return _ref6.apply(this, arguments);
  };
}();
const _delete = exports._delete = /*#__PURE__*/function () {
  var _ref7 = _asyncToGenerator(function* (httpClient, path, config, auth) {
    return httpRequest(httpClient, 'delete', path, config, auth);
  });
  return function _delete(_x32, _x33, _x34, _x35) {
    return _ref7.apply(this, arguments);
  };
}();
var _default = exports.default = createAccessToken;
//# sourceMappingURL=http.js.map